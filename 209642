#ifndef DOUBLETAB_HXX_
#define DOUBLETAB_HXX_

#include <iostream>
#include <vector>
#include <algorithm>
#include <stdexcept>

class DoubleTab {
public:
    // ... (constructors, destructor, resize, accessors, max, min) ... 

    // Copy assignment operator
    DoubleTab& operator=(const DoubleTab& dt) {
        if (this != &dt) { 
            delete[] _values;
            _numberOfElements = dt._numberOfElements;
            _values = new double[_numberOfElements];
            std::copy(dt._values, dt._values + _numberOfElements, _values);
        }
        return *this;
    }
  
  //Updated DoubleTab(const int size, const double* values)
    DoubleTab(int size, const double* values) : _numberOfElements(size) {
        if (_numberOfElements < 0)
           throw std::invalid_argument("Negative array size not allowed");
        _values = new double[_numberOfElements];
        std::copy(values, values + _numberOfElements, _values);
    }

    // ... (indexing operators [], (), compound assignment operators +=, -=, *=, /=) ...

    // Binary arithmetic operators (+, -, *, /)
    friend DoubleTab operator+(const DoubleTab& U, const DoubleTab& V) {
        DoubleTab result(U);
        result += V;
        return result;
    }

    friend DoubleTab operator-(const DoubleTab& U, const DoubleTab& V) {
        DoubleTab result(U);
        result -= V;
        return result;
    }

    friend DoubleTab operator*(const DoubleTab& U, const DoubleTab& V) {
        DoubleTab result(U);
        result *= V;
        return result;
    }

    friend DoubleTab operator/(const DoubleTab& U, const DoubleTab& V) {
        DoubleTab result(U);
        result /= V;
        return result;
    }

    // Scalar multiplication operators (* and /)
    friend DoubleTab operator*(double value, const DoubleTab& V) {
        DoubleTab result(V);
        result *= value;
        return result;
    }

    friend DoubleTab operator*(const DoubleTab& U, double value) {
        return value * U; 
    }

    friend DoubleTab operator/(const DoubleTab& U, double value) {
        if(value == 0)
          throw std::runtime_error("Error, the divisor cannot be zero.");
        DoubleTab result(U);
        result /= value;
        return result;
    }

    // Dot product operator (*)
    friend double operator*(const DoubleTab& U, const DoubleTab& V) {
        if (U.size() != V.size()) {
            throw std::runtime_error("DoubleTabs must have the same size for dot product");
        }
        double result = 0.0;
        for (int i = 0; i < U.size(); ++i) {
            result += U[i] * V[i]; 
        }
        return result;
    }

    // Output stream operator (<<)
    friend std::ostream& operator<<(std::ostream& out, const DoubleTab& U) {
        out << "[";
        for (int i = 0; i < U.size(); ++i) {
            out << U[i];
            if (i < U.size() - 1) { 
                out << ", ";
            }
        }
        out << "]";
        return out;
    }


private:
    double* _values;
    int _numberOfElements;
};

#endif 
# ... (rest of your CMakeLists.txt)

# Hash Validation (Update with ACTUAL hashes)
set(HASHES
  "DoubleTab.hxx" 
    MD5 cdecf0b3a602259cadac104f69ddd636
    SHA1 67f8568d4a36ea5d7144352c1331a92c04ed6f25
    SHA256 19a7f22218ce09785ffb071788ccb643a008624c473762f13ea62e9574cb3e41  
)

# ... (rest of your CMakeLists.txt)
